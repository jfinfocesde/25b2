#  Semana 5: Entidades en Spring Boot

## Introducción

En Spring Boot, una **entidad** es una clase Java que representa una tabla en una base de datos relacional. Las entidades son fundamentales en aplicaciones que utilizan **Spring Data JPA** para mapear objetos Java a registros de bases de datos (ORM - Object-Relational Mapping).

---

## ¿Qué es una entidad en Spring Boot?

Una entidad es una clase Java anotada con `@Entity` que se mapea a una tabla en la base de datos. Cada instancia de la entidad representa una fila en la tabla, y los atributos de la clase representan las columnas. Las entidades son gestionadas por el **EntityManager** de JPA y se utilizan comúnmente con Spring Data JPA para operaciones CRUD.

---

## Anotaciones comunes para entidades

A continuación, se describen las anotaciones más comunes utilizadas en entidades de Spring Boot con JPA, junto con su propósito:

### 1. `@Entity`
Indica que la clase es una entidad y debe ser mapeada a una tabla en la base de datos.

- **Uso**: Se coloca encima de la clase.
- **Ejemplo**: `@Entity public class Producto { ... }`
- **Nota**: La clase debe tener un constructor sin argumentos (puede ser implícito con Lombok).

### 2. `@Table`
Especifica el nombre de la tabla en la base de datos a la que se mapea la entidad. Si no se usa, JPA asume que la tabla tiene el mismo nombre que la clase.

- **Atributos comunes**:
  - `name`: Nombre de la tabla.
  - `schema`: Esquema de la base de datos (opcional).
- **Ejemplo**: `@Table(name = "productos")`

### 3. `@Id`
Marca un campo como la clave primaria de la entidad.

- **Uso**: Se coloca en el atributo que representa la clave primaria.
- **Ejemplo**: `@Id private Long id;`

### 4. `@GeneratedValue`
Define la estrategia para generar automáticamente los valores de la clave primaria.

- **Atributos comunes**:
  - `strategy`: Estrategia de generación (`AUTO`, `IDENTITY`, `SEQUENCE`, `TABLE`).
  - `generator`: Nombre del generador personalizado (opcional).
- **Ejemplo**: `@GeneratedValue(strategy = GenerationType.IDENTITY)`
- **Estrategias**:
  - `AUTO`: JPA elige la estrategia según la base de datos.
  - `IDENTITY`: Usa la funcionalidad de autoincremento de la base de datos.
  - `SEQUENCE`: Usa una secuencia de base de datos (por ejemplo, en PostgreSQL).
  - `TABLE`: Usa una tabla auxiliar para generar IDs.

### 5. `@Column`
Especifica detalles sobre cómo un atributo se mapea a una columna en la base de datos.

- **Atributos comunes**:
  - `name`: Nombre de la columna.
  - `nullable`: Indica si la columna permite valores nulos (`true` o `false`).
  - `length`: Longitud máxima para campos de tipo cadena.
  - `unique`: Indica si la columna debe ser única.
- **Ejemplo**: `@Column(name = "nombre_producto", nullable = false, length = 100)`

### 6. `@Temporal`
Se usa para mapear campos de tipo `java.util.Date` o `java.util.Calendar` a columnas de tipo fecha o hora en la base de datos.

- **Atributos**:
  - `TemporalType.DATE`: Solo fecha (sin hora).
  - `TemporalType.TIME`: Solo hora.
  - `TemporalType.TIMESTAMP`: Fecha y hora.
- **Ejemplo**: `@Temporal(TemporalType.DATE) private Date fechaCreacion;`
- **Nota**: Desde Java 8, se recomienda usar `LocalDate`, `LocalTime` o `LocalDateTime` con `@Column`, ya que son más robustos.

### 7. `@Enumerated`
Mapea un campo de tipo `enum` a una columna en la base de datos.

- **Atributos**:
  - `EnumType.STRING`: Almacena el nombre del enum como cadena.
  - `EnumType.ORDINAL`: Almacena el índice del enum (0, 1, 2, ...).
- **Ejemplo**: `@Enumerated(EnumType.STRING) private EstadoProducto estado;`

### 8. `@Transient`
Indica que un campo no debe ser persistido en la base de datos.

- **Uso**: Para campos calculados o temporales.
- **Ejemplo**: `@Transient private String campoCalculado;`

### 9. Anotaciones de Lombok
Lombok reduce el código repetitivo al generar automáticamente métodos como getters, setters, constructores, etc.

- **`@Getter`**: Genera getters para todos los campos.
- **`@Setter`**: Genera setters para todos los campos.
- **`@NoArgsConstructor`**: Genera un constructor sin argumentos.
- **`@AllArgsConstructor`**: Genera un constructor con todos los argumentos.
- **`@ToString`**: Genera un método `toString()`.
- **`@EqualsAndHashCode`**: Genera métodos `equals()` y `hashCode()`.
- **`@Data`**: Combina `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode` y `@RequiredArgsConstructor`.
- **Ejemplo**: `@Data public class Producto { ... }`

---

## Ejemplo práctico: Entidad `Producto`

Vamos a crear una entidad `Producto` que representa un producto en una tienda en línea. 

### Código de la entidad

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Table(name = "productos")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Producto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nombre_producto", nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false)
    private Double precio;

    @Column(name = "fecha_creacion")
    private LocalDate fechaCreacion;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private EstadoProducto estado;

    @Transient
    private String descripcionCompleta;
}

enum EstadoProducto {
    ACTIVO, INACTIVO, DESCONTINUADO
}
```

### Explicación del ejemplo

- **`@Entity`**: Declara la clase como una entidad JPA.
- **`@Table(name = "productos")`**: Mapea la entidad a la tabla `productos` en la base de datos.
- **`@Data`**: Genera getters, setters, `toString()`, `equals()` y `hashCode()` automáticamente.
- **`@NoArgsConstructor` y `@AllArgsConstructor`**: Generan constructores sin argumentos y con todos los argumentos, respectivamente.
- **`@Id` y `@GeneratedValue`**: Definen `id` como clave primaria con autoincremento.
- **`@Column`**: Especifica detalles de las columnas, como nombres y restricciones.
- **`@Enumerated(EnumType.STRING)`**: Almacena el enum `EstadoProducto` como una cadena en la base de datos.
- **`@Transient`**: El campo `descripcionCompleta` no se persiste en la base de datos.

---

## Buenas prácticas para entidades

1. **Usar Lombok con moderación**: Aunque `@Data` es útil, considera usar `@Getter` y `@Setter` individualmente para controlar qué métodos se generan.
2. **Definir restricciones claras**: Usa `@Column(nullable = false)` y otras restricciones para garantizar la integridad de los datos.
3. **Evitar lógica de negocio en entidades**: Las entidades deben ser simples y solo representar datos. La lógica debe ir en servicios.
4. **Usar tipos modernos para fechas**: Prefiere `LocalDate`, `LocalDateTime` en lugar de `java.util.Date`.
5. **Nombres explícitos**: Usa `@Table` y `@Column` para definir nombres claros en la base de datos, evitando conflictos.

---

## Relaciones en Spring Boot con JPA

En Spring Boot, las relaciones entre entidades son fundamentales para modelar asociaciones entre tablas en una base de datos relacional utilizando **Spring Data JPA**. Estas relaciones se definen mediante anotaciones de JPA como `@OneToOne`, `@OneToMany`, `@ManyToOne` y `@ManyToMany`. Además, para manejar la serialización de objetos a JSON y evitar problemas como bucles infinitos, se utilizan anotaciones como `@JsonManagedReference` y `@JsonBackReference` de Jackson. Este documento explica en detalle todas las formas de relaciones en JPA, sus configuraciones, ejemplos prácticos con la entidad `Producto` y una nueva entidad `Categoria`, y el uso de estas anotaciones de Jackson.

---

### Tipos de relaciones en JPA

JPA soporta cuatro tipos principales de relaciones entre entidades:

1. **One-to-One** (`@OneToOne`): Una entidad está asociada a exactamente una instancia de otra entidad.
2. **One-to-Many** (`@OneToMany`): Una entidad está asociada a múltiples instancias de otra entidad.
3. **Many-to-One** (`@ManyToOne`): Múltiples instancias de una entidad están asociadas a una sola instancia de otra entidad.
4. **Many-to-Many** (`@ManyToMany`): Múltiples instancias de una entidad están asociadas a múltiples instancias de otra entidad.

A continuación, se explican cada una con ejemplos prácticos usando las entidades `Producto` y `Categoria`, incluyendo las anotaciones `@JsonManagedReference` y `@JsonBackReference` para manejar la serialización JSON.

---

### Anotaciones clave para relaciones

#### Anotaciones de JPA
- **`@OneToOne`**: Define una relación uno a uno.
- **`@OneToMany`**: Define una relación uno a muchos.
- **`@ManyToOne`**: Define una relación muchos a uno.
- **`@ManyToMany`**: Define una relación muchos a muchos.
- **`@JoinColumn`**: Especifica la columna de la clave foránea en la base de datos.
- **`@JoinTable`**: Define una tabla intermedia para relaciones muchos a muchos.
- **`mappedBy`**: Indica el lado "inverso" de una relación bidireccional, especificando el campo en la otra entidad que gestiona la relación.

#### Anotaciones de Jackson
- **`@JsonManagedReference`**: Se usa en el lado "padre" de una relación para indicar que este campo debe incluirse en la serialización JSON.
- **`@JsonBackReference`**: Se usa en el lado "hijo" para evitar bucles infinitos durante la serialización JSON, excluyendo este campo de la serialización.

---

### Ejemplo práctico: Entidades `Producto` y `Categoria`

Vamos a modelar una tienda en línea con dos entidades: `Producto` (un producto en venta) y `Categoria` (la categoría a la que pertenece el producto). Usaremos **Lombok** para reducir código repetitivo y definiremos todas las relaciones posibles entre estas entidades. Cada ejemplo incluye las anotaciones de JPA y Jackson, con explicaciones detalladas.

---

### 1. Relación One-to-One

Una relación **uno a uno** implica que una instancia de una entidad está asociada a exactamente una instancia de otra entidad. Por ejemplo, un `Producto` puede tener una única `Categoria` exclusiva (en este caso, asumimos que cada producto pertenece a una categoría única).

#### Código

##### Entidad `Producto`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.time.LocalDate;

@Entity
@Table(name = "productos")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Producto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nombre_producto", nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false)
    private Double precio;

    @Column(name = "fecha_creacion")
    private LocalDate fechaCreacion;

    @OneToOne
    @JoinColumn(name = "categoria_id", referencedColumnName = "id")
    @JsonManagedReference
    private Categoria categoria;
}
```

##### Entidad `Categoria`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;

@Entity
@Table(name = "categorias")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String nombre;

    @OneToOne(mappedBy = "categoria")
    @JsonBackReference
    private Producto producto;
}
```

#### Explicación

- **En `Producto`**:
  - `@OneToOne`: Define la relación uno a uno con `Categoria`.
  - `@JoinColumn(name = "categoria_id")`: Crea una columna `categoria_id` en la tabla `productos` como clave foránea que referencia la tabla `categorias`.
  - `@JsonManagedReference`: Indica que `Producto` es el lado "padre" y se incluirá en la serialización JSON.

- **En `Categoria`**:
  - `@OneToOne(mappedBy = "categoria")`: Indica que `Producto` es el propietario de la relación (el lado que tiene la clave foránea). El campo `categoria` en `Producto` gestiona la relación.
  - `@JsonBackReference`: Evita que el campo `producto` se serialice, previniendo bucles infinitos (por ejemplo, `Producto -> Categoria -> Producto`).

- **Serialización JSON**: Cuando serializas un `Producto`, obtendrás su `Categoria`, pero no al revés. Esto evita problemas de recursión infinita.

- **Estructura en la base de datos**:
  - Tabla `productos`: Columnas `id`, `nombre_producto`, `precio`, `fecha_creacion`, `categoria_id`.
  - Tabla `categorias`: Columnas `id`, `nombre`.

---

### 2. Relación Many-to-One y One-to-Many

Una relación **muchos a uno** implica que múltiples instancias de una entidad están asociadas a una sola instancia de otra entidad. Por ejemplo, varios `Producto`s pueden pertenecer a una misma `Categoria`. La relación inversa es **uno a muchos**, donde una `Categoria` puede tener varios `Producto`s.

#### Código

##### Entidad `Producto`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;
import java.time.LocalDate;

@Entity
@Table(name = "productos")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Producto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nombre_producto", nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false)
    private Double precio;

    @Column(name = "fecha_creacion")
    private LocalDate fechaCreacion;

    @ManyToOne
    @JoinColumn(name = "categoria_id", nullable = false)
    @JsonBackReference
    private Categoria categoria;
}
```

##### Entidad `Categoria`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.util.List;

@Entity
@Table(name = "categorias")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String nombre;

    @OneToMany(mappedBy = "categoria", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonManagedReference
    private List<Producto> productos;
}
```

#### Explicación

- **En `Producto`**:
  - `@ManyToOne`: Indica que muchos `Producto`s pueden estar asociados a una sola `Categoria`.
  - `@JoinColumn(name = "categoria_id")`: Crea una columna `categoria_id` en la tabla `productos` como clave foránea.
  - `@JsonBackReference`: Evita serializar el campo `categoria` para prevenir bucles infinitos.

- **En `Categoria`**:
  - `@OneToMany(mappedBy = "categoria")`: Define la relación inversa, indicando que el campo `categoria` en `Producto` gestiona la relación.
  - `cascade = CascadeType.ALL`: Propaga operaciones (como guardar o eliminar) de `Categoria` a sus `Producto`s asociados.
  - `fetch = FetchType.LAZY`: Carga los `Producto`s asociados solo cuando se accede a ellos (optimización).
  - `@JsonManagedReference`: Incluye la lista de `Producto`s en la serialización JSON de `Categoria`.

- **Serialización JSON**: Al serializar una `Categoria`, obtendrás su lista de `Producto`s, pero al serializar un `Producto`, no se incluirá la `Categoria` para evitar recursión.

- **Estructura en la base de datos**:
  - Tabla `productos`: Columnas `id`, `nombre_producto`, `precio`, `fecha_creacion`, `categoria_id`.
  - Tabla `categorias`: Columnas `id`, `nombre`.

---

### 3. Relación Many-to-Many

Una relación **muchos a muchos** implica que múltiples instancias de una entidad pueden estar asociadas a múltiples instancias de otra entidad. Por ejemplo, un `Producto` puede pertenecer a varias `Categoria`s, y una `Categoria` puede estar asociada a varios `Producto`s. Esto requiere una tabla intermedia.

#### Código

##### Entidad `Producto`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.time.LocalDate;
import java.util.List;

@Entity
@Table(name = "productos")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Producto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nombre_producto", nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false)
    private Double precio;

    @Column(name = "fecha_creacion")
    private LocalDate fechaCreacion;

    @ManyToMany
    @JoinTable(
        name = "producto_categoria",
        joinColumns = @JoinColumn(name = "producto_id"),
        inverseJoinColumns = @JoinColumn(name = "categoria_id")
    )
    @JsonManagedReference
    private List<Categoria> categorias;
}
```

##### Entidad `Categoria`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;
import java.util.List;

@Entity
@Table(name = "categorias")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String nombre;

    @ManyToMany(mappedBy = "categorias")
    @JsonBackReference
    private List<Producto> productos;
}
```

#### Explicación

- **En `Producto`**:
  - `@ManyToMany`: Define la relación muchos a muchos con `Categoria`.
  - `@JoinTable`: Crea una tabla intermedia `producto_categoria` con dos columnas: `producto_id` (clave foránea a `productos`) y `categoria_id` (clave foránea a `categorias`).
  - `@JsonManagedReference`: Incluye la lista de `Categoria`s en la serialización JSON de `Producto`.

- **En `Categoria`**:
  - `@ManyToMany(mappedBy = "categorias")`: Indica que `Producto` es el propietario de la relación, y el campo `categorias` en `Producto` gestiona la relación.
  - `@JsonBackReference`: Evita serializar la lista de `Producto`s para prevenir bucles infinitos.

- **Serialización JSON**: Al serializar un `Producto`, obtendrás sus `Categoria`s, pero al serializar una `Categoria`, no se incluirán los `Producto`s.

- **Estructura en la base de datos**:
  - Tabla `productos`: Columnas `id`, `nombre_producto`, `precio`, `fecha_creacion`.
  - Tabla `categorias`: Columnas `id`, `nombre`.
  - Tabla `producto_categoria`: Columnas `producto_id`, `categoria_id`.

---

### Notas sobre `@JsonManagedReference` y `@JsonBackReference`

- **Propósito**: Estas anotaciones evitan bucles infinitos durante la serialización JSON en relaciones bidireccionales. Sin ellas, serializar un `Producto` incluiría su `Categoria`, que a su vez incluiría el `Producto`, y así sucesivamente.
- **Uso**:
  - `@JsonManagedReference` se coloca en el lado que deseas incluir en la serialización (generalmente el "padre").
  - `@JsonBackReference` se coloca en el lado que deseas excluir (generalmente el "hijo").
- **Alternativas**: Si no deseas usar estas anotaciones, puedes usar `@JsonIgnore` en uno de los lados de la relación, pero esto excluye completamente el campo de la serialización. Otra opción es usar DTOs (Data Transfer Objects) para controlar manualmente qué datos se serializan.

---

### Buenas prácticas para relaciones

1. **Elegir el lado propietario**: En relaciones bidireccionales, siempre define un lado propietario (el que tiene la clave foránea o la `@JoinTable`) usando `mappedBy` en el lado inverso.
2. **Usar `cascade` con cuidado**: Configura `cascade = CascadeType.ALL` solo si deseas propagar operaciones (como eliminar) a las entidades relacionadas.
3. **Configurar `fetch` apropiadamente**:
   - `FetchType.LAZY`: Carga datos solo cuando se accede (mejor para rendimiento).
   - `FetchType.EAGER`: Carga datos inmediatamente (puede causar problemas de rendimiento).
4. **Evitar bucles infinitos**: Usa `@JsonManagedReference` y `@JsonBackReference` o DTOs para manejar serialización JSON.
5. **Validar datos**: Usa `@NotNull` o restricciones en la base de datos para garantizar la integridad de las relaciones.
6. **Evitar relaciones innecesarias**: Modela solo las relaciones necesarias para tu caso de uso para mantener el diseño simple.

---


### Ejemplo Completo de Relaciones en Spring Boot con Jackson

Ejemplo completo que integra todas las relaciones en Spring Boot con **Spring Data JPA**: **uno a uno**, **uno a muchos/muchos a uno**, y **muchos a muchos**, utilizando las anotaciones `@JsonManagedReference` y `@JsonBackReference` de Jackson para gestionar la serialización JSON en relaciones bidireccionales. El caso práctico se basa en una tienda en línea con las entidades `Cliente`, `Perfil`, `Pedido`, `Producto`, y `Categoria`.

---

## Descripción del caso

En una tienda en línea:
- Un `Cliente` tiene un único `Perfil` (relación **uno a uno** bidireccional).
- Un `Cliente` puede tener múltiples `Pedidos`, y cada `Pedido` pertenece a un único `Cliente` (relación **uno a muchos/muchos a uno** bidireccional).
- Un `Pedido` puede contener múltiples `Productos`, y un `Producto` puede estar en múltiples `Pedidos` (relación **muchos a muchos** bidireccional).
- Un `Producto` puede pertenecer a múltiples `Categorias`, y una `Categoria` puede estar asociada con múltiples `Productos` (relación **muchos a muchos** bidireccional).

---

## Código de las entidades

### Entidad `Cliente`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "clientes")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String nombre;

    @Column(nullable = false, unique = true)
    private String email;

    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "perfil_id", nullable = false)
    @JsonManagedReference
    private Perfil perfil;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    @JsonManagedReference
    private List<Pedido> pedidos = new ArrayList<>();
}
```

### Entidad `Perfil`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;
import java.time.LocalDate;

@Entity
@Table(name = "perfiles")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Perfil {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String telefono;

    @Column
    private LocalDate fechaNacimiento;

    @Column(length = 200)
    private String direccion;

    @OneToOne(mappedBy = "perfil", fetch = FetchType.LAZY)
    @JsonBackReference
    private Cliente cliente;
}
```

### Entidad `Pedido`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "pedidos")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Pedido {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private LocalDate fecha;

    @Column(nullable = false)
    private Double total;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "cliente_id", nullable = false)
    @JsonBackReference
    private Cliente cliente;

    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}, fetch = FetchType.LAZY)
    @JoinTable(
        name = "pedido_producto",
        joinColumns = @JoinColumn(name = "pedido_id"),
        inverseJoinColumns = @JoinColumn(name = "producto_id")
    )
    @JsonManagedReference
    private Set<Producto> productos = new HashSet<>();
}
```

### Entidad `Producto`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "productos")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Producto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false)
    private Double precio;

    @ManyToMany(mappedBy = "productos", fetch = FetchType.LAZY)
    @JsonBackReference
    private Set<Pedido> pedidos = new HashSet<>();

    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}, fetch = FetchType.LAZY)
    @JoinTable(
        name = "producto_categoria",
        joinColumns = @JoinColumn(name = "producto_id"),
        inverseJoinColumns = @JoinColumn(name = "categoria_id")
    )
    @JsonManagedReference
    private Set<Categoria> categorias = new HashSet<>();
}
```

### Entidad `Categoria`

```java
package com.tienda.model;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonBackReference;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "categorias")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String nombre;

    @Column(length = 200)
    private String descripcion;

    @ManyToMany(mappedBy = "categorias", fetch = FetchType.LAZY)
    @JsonBackReference
    private Set<Producto> productos = new HashSet<>();
}
```

---












